//-------------------------------------------------------------------------
// Parallel.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL VerilogPlaceholder ParallelTestHarnessVRTL Definition
// Full name: ParallelTestHarnessVRTL__BIT_WIDTH_32__N_SAMPLES_8
// At /home/vml37/c2s2/parallel3/rtl_design/sim/parallel/ParallelTestHarnessRTL.py

//***********************************************************
// Pickled source file of placeholder ParallelTestHarnessVRTL__BIT_WIDTH_32__N_SAMPLES_8
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder ParallelTestHarnessVRTL
//-----------------------------------------------------------

`ifndef PARALLELTESTHARNESSVRTL
`define PARALLELTESTHARNESSVRTL

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component ParallelTestHarnessVRTL__BIT_WIDTH_32__N_SAMPLES_8.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component ParallelTestHarnessVRTL__BIT_WIDTH_32__N_SAMPLES_8

`line 1 "ParallelTestHarnessVRTL.v" 0
`line 1 "./ParallelVRTL.v" 0
module ControlVRTL 
#(
    parameter dec_in = 1, //#decoder input lines
    parameter N_SAMPLES = 1 << dec_in //#decoder output lines
)(
    input   logic recv_val,
    input   logic send_rdy,
    input   logic reset,
    input   logic clk,

    output  logic send_val,
    output  logic recv_rdy,
    output  logic [dec_in-1:0] dsel //input to decoder
);
    parameter [1:0] Init = 2'b00;
    parameter [1:0] State1 = 2'b01;
    parameter [1:0] State2 = 2'b10; 

    logic [N_SAMPLES-1:0] count; //counter
    logic [1:0] Scurr;
    logic [1:0] Snext;

    always @(recv_val, send_rdy, Scurr) begin 
       case(Scurr)
            Init: begin 
                if ((recv_val == 1) & (count != N_SAMPLES)) 
                    Snext = State1;
                else if ((recv_val == 1) & (count == N_SAMPLES)) 
                    Snext = State2;
                else 
                    Snext = Init;
                end

            State1: Snext = Init;

            State2: begin
                if (send_rdy == 1) Snext = Init; 
                else Snext = State2;
            end 

            default: Snext = 1'd0;
        endcase
    end  

    always @(Scurr) begin 
        if (Scurr == Init) begin 
            count = count;
            recv_rdy = 1'b1;
            send_val = 1'b0;
        end 

        else if (Scurr == State1) begin 
            recv_rdy = 1'b1;
            send_val = 1'b0;
            dsel = count;
            count = count + 1;
        end

        else if (Scurr == State2) begin 
            count = count;
            recv_rdy = 1'b0;
            send_val = 1'b1;
            dsel = count;
        end 

        else begin //reset
            count = 0;
            recv_rdy = 1'b1;
            send_val = 1'b0;
            dsel = 1'b0;
        end 
    end

    always @ (posedge clk) begin 
        if (reset == 1) Scurr = Init; else Scurr = Snext;
    end 

endmodule

module DecoderVRTL (
	x,
	y
);
    `ifdef USE_POWER_PINS
    inout vccd1, // User area 1 1.8V supply
    inout vssd1, // User area 1 digital ground
    `endif
	parameter m = 3;
	parameter n = 1 << m;
	input wire [m - 1:0] x;
	output reg [n - 1:0] y;
	always @(*) y = {{n - 1 {1'b0}}, 1'b1} << x;
endmodule

module RegisterV
	#(parameter BIT_WIDTH  = 32)
	(clk, reset, w, d, q);
    input logic clk;
    input logic reset;
    input  logic w;
    input logic [BIT_WIDTH-1:0] d;
    output logic [BIT_WIDTH-1:0] q;
    logic [BIT_WIDTH-1:0] regout;

    assign q = regout;

    always @(posedge clk) begin
	if (reset)
	    regout <= 0;
	else if (w)
	    regout <= d;
    end
endmodule

module ParallelVRTL
#(
	parameter dec_in = 3,					//decoder inputs
    parameter N_SAMPLES = 1 << dec_in, 	//number of outputs to decoder/#of registers
	parameter BIT_WIDTH  = 32
)(
	input logic clk, 
	input logic reset,
	input logic recv_val, 
	input logic send_rdy, 
	input logic [BIT_WIDTH - 1:0] recv_msg,

	output logic send_val, 
	output logic recv_rdy,
    output logic [BIT_WIDTH - 1:0] send_msg [N_SAMPLES - 1:0]
);
    logic [dec_in-1:0] dec_select;
    logic [N_SAMPLES-1:0] dec_out;
    //body of code
	ControlVRTL c
		(
			.recv_val(recv_val), 
			.send_rdy(send_rdy),
			.reset(reset),
			.clk(clk),
			.send_val(send_val),
			.recv_rdy(recv_rdy), 
			.dsel(dec_select)
		);

	DecoderVRTL #(.m(dec_in), .n(N_SAMPLES)) d
		(
			.x(dec_select),
			.y(dec_out)
		);  

    generate
        genvar i;
        for( i = 0; i < N_SAMPLES; i++) begin
            RegisterV #( .BIT_WIDTH(BIT_WIDTH) ) register ( .clk(clk), .reset(reset), .w(dec_select[i]), .d(recv_msg), .q(send_msg[i]) );
        end
    endgenerate

endmodule



`line 2 "ParallelTestHarnessVRTL.v" 0

module ParallelTestHarnessVRTL
    #(
        dec_in = 1,
        BIT_WIDTH  = 32,
        N_SAMPLES  = 8
    )
    (
        input  logic [BIT_WIDTH - 1:0] recv_msg,
        input  logic                   recv_val,
        output logic                   recv_rdy,

        output logic [BIT_WIDTH - 1:0] send_msg [N_SAMPLES - 1:0],
        input  logic                   send_rdy,
        output logic                   send_val,

        input  logic                   reset,
        input  logic                   clk
    );
    
    logic [BIT_WIDTH - 1:0] send_msg_intermediate [N_SAMPLES - 1:0];

    always @(*) begin
        int i;
        for(i = 0; i < 2 * N_SAMPLES; i = i + 1) begin

            send_msg   [BIT_WIDTH * i +: BIT_WIDTH] = send_msg_intermediate [i][BIT_WIDTH - 1:0];
        end
    end

    ParallelVRTL #( .dec_in(dec_in), .N_SAMPLES(N_SAMPLES), .BIT_WIDTH(32)) parallel
    (
        .recv_msg(recv_msg),
        .recv_val(recv_val),
        .recv_rdy(recv_rdy),

        .send_msg(send_msg_intermediate),
        .send_val(send_val),
        .send_rdy(send_rdy),

        .reset(reset),
        .clk(clk)
    );
endmodule
`endif /* PARALLELTESTHARNESSVRTL */
//-----------------------------------------------------------
// Wrapper of placeholder ParallelTestHarnessVRTL__BIT_WIDTH_32__N_SAMPLES_8
//-----------------------------------------------------------

`ifndef PARALLELTESTHARNESSVRTL__BIT_WIDTH_32__N_SAMPLES_8
`define PARALLELTESTHARNESSVRTL__BIT_WIDTH_32__N_SAMPLES_8

module Parallel
(
  input logic [1-1:0] clk ,
  input logic [1-1:0] reset ,
  input logic [32-1:0] recv_msg ,
  output logic [1-1:0] recv_rdy ,
  input logic [1-1:0] recv_val ,
  output logic [256-1:0] send_msg ,
  input logic [1-1:0] send_rdy ,
  output logic [1-1:0] send_val 
);
  ParallelTestHarnessVRTL
  #(
    .BIT_WIDTH( 32 ),
    .N_SAMPLES( 8 )
  ) v
  (
    .clk( clk ),
    .reset( reset ),
    .recv_msg( recv_msg ),
    .recv_rdy( recv_rdy ),
    .recv_val( recv_val ),
    .send_msg( send_msg ),
    .send_rdy( send_rdy ),
    .send_val( send_val )
  );
endmodule

`endif /* PARALLELTESTHARNESSVRTL__BIT_WIDTH_32__N_SAMPLES_8 */

