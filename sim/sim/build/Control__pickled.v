//-------------------------------------------------------------------------
// Control.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL VerilogPlaceholder ControlVRTL Definition
// Full name: ControlVRTL__dib_1__dobreg_2
// At /home/vml37/c2s2/parallel3/rtl_design/sim/parallel/ControlVRTL.py

//***********************************************************
// Pickled source file of placeholder ControlVRTL__dib_1__dobreg_2
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder ControlVRTL
//-----------------------------------------------------------

`ifndef CONTROLVRTL
`define CONTROLVRTL

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component ControlVRTL__dib_1__dobreg_2.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component ControlVRTL__dib_1__dobreg_2

`line 1 "ControlVRTL.v" 0
module ControlVRTL 
#(
    parameter dib = 1, //#decoder input lines
    parameter dobreg = 1 << dib //#decoder output lines
)(
    input   logic recv_val,
    input   logic send_rdy,
    input   logic reset,
    input   logic clk,

    output  logic send_val,
    output  logic recv_rdy,
    output  logic [dib-1:0] dsel //input to decoder
);
    parameter [1:0] Init = 2'b00;
    parameter [1:0] State1 = 2'b01;
    parameter [1:0] State2 = 2'b10; 

    logic [dobreg-1:0] count; //counter
    logic [1:0] Scurr;
    logic [1:0] Snext;

    always @(recv_val, send_rdy, Scurr) begin 
       case(Scurr)
            Init: begin 
                if ((recv_val == 1) & (count != dobreg)) 
                    Snext = State1;
                else if ((recv_val == 1) & (count == dobreg)) 
                    Snext = State2;
                else 
                    Snext = Init;
                end

            State1: Snext = Init;

            State2: begin
                if (send_rdy == 1) Snext = Init; 
                else Snext = State2;
            end 

            default: Snext = 1'd0;
        endcase
    end  

    always @(Scurr) begin 
        if (Scurr == Init) begin 
            count = count;
            recv_rdy = 1'b1;
            send_val = 1'b0;
        end 

        else if (Scurr == State1) begin 
            recv_rdy = 1'b1;
            send_val = 1'b0;
            dsel = count;
            count = count + 1;
        end

        else if (Scurr == State2) begin 
            count = count;
            recv_rdy = 1'b0;
            send_val = 1'b1;
            dsel = count;
        end 

        else begin //reset
            count = 0;
            recv_rdy = 1'b1;
            send_val = 1'b0;
            dsel = 1'b0;
        end 
    end

    always @ (posedge clk) begin 
        if (reset == 1) Scurr = Init; else Scurr = Snext;
    end 

endmodule

`endif /* CONTROLVRTL */
//-----------------------------------------------------------
// Wrapper of placeholder ControlVRTL__dib_1__dobreg_2
//-----------------------------------------------------------

`ifndef CONTROLVRTL__DIB_1__DOBREG_2
`define CONTROLVRTL__DIB_1__DOBREG_2

module Control
(
  input logic [1-1:0] clk ,
  output logic [1-1:0] dsel ,
  output logic [1-1:0] recv_rdy ,
  input logic [1-1:0] recv_val ,
  input logic [1-1:0] reset ,
  input logic [1-1:0] send_rdy ,
  output logic [1-1:0] send_val 
);
  ControlVRTL
  #(
    .dib( 1 ),
    .dobreg( 2 )
  ) v
  (
    .clk( clk ),
    .dsel( dsel ),
    .recv_rdy( recv_rdy ),
    .recv_val( recv_val ),
    .reset( reset ),
    .send_rdy( send_rdy ),
    .send_val( send_val )
  );
endmodule

`endif /* CONTROLVRTL__DIB_1__DOBREG_2 */

